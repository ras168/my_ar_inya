<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/aframe-ar.js"></script>
    <script src="https://unpkg.com/micromodal/dist/micromodal.min.js"></script>
    <link href="ar.css" rel="stylesheet" />
    <script>
      // sprite-sheet: スプライトシートをコマ送り表示するコンポーネント
      AFRAME.registerComponent("sprite-sheet", {
        schema: {
          cols: { type: "int", default: 4 },
          rows: { type: "int", default: 4 },
          fps: { type: "number", default: 12 },
          loop: { type: "boolean", default: true },
          autoplay: { type: "boolean", default: true },
          pingpong: { type: "boolean", default: false },
          startFrame: { type: "int", default: 0 },
          endFrame: { type: "int", default: -1 },
          pixelated: { type: "boolean", default: false },
        },
        init() {
          this.map = null;
          this.timeAcc = 0;
          this.frame = this.data.startFrame;
          this.dir = 1;

          const setup = (tex) => {
            this.map = tex;
            const t = this.map;
            if (!t) return;
            t.wrapS = t.wrapT = THREE.RepeatWrapping;
            if (this.data.pixelated) {
              t.minFilter = THREE.NearestFilter;
              t.magFilter = THREE.NearestFilter;
            }
            this._applyRepeat();
            this._goto(this.frame);
            t.needsUpdate = true;
          };

          const mesh = this.el.getObject3D("mesh");
          if (mesh && mesh.material && mesh.material.map)
            setup(mesh.material.map);
          this.el.addEventListener("materialtextureloaded", (e) =>
            setup(e.detail.texture)
          );
        },
        update(old) {
          if (!this.map) return;
          if (
            !old ||
            old.cols !== this.data.cols ||
            old.rows !== this.data.rows
          ) {
            this._applyRepeat();
            this._goto(this.frame);
          }
        },
        _applyRepeat() {
          const rx = 1 / this.data.cols;
          const ry = 1 / this.data.rows;
          this.map.repeat.set(rx, ry);
          this.rx = rx;
          this.ry = ry;
        },
        _goto(f) {
          const total = this.data.cols * this.data.rows;
          const last = this.data.endFrame >= 0 ? this.data.endFrame : total - 1;
          const first = this.data.startFrame;
          f = Math.max(first, Math.min(last, f));
          const col = f % this.data.cols;
          const row = Math.floor(f / this.data.cols);
          this.map.offset.x = col * this.rx;
          this.map.offset.y = 1 - this.ry - row * this.ry;
          this.frame = f;
        },
        _step() {
          const total = this.data.cols * this.data.rows;
          const last = this.data.endFrame >= 0 ? this.data.endFrame : total - 1;
          const first = this.data.startFrame;
          let next = this.frame + this.dir;
          if (next > last) {
            if (this.data.pingpong) {
              this.dir = -1;
              next = last - 1;
            } else if (this.data.loop) {
              next = first;
            } else {
              next = last;
              this.data.autoplay = false;
            }
          } else if (next < first) {
            if (this.data.pingpong) {
              this.dir = 1;
              next = first + 1;
            } else if (this.data.loop) {
              next = last;
            } else {
              next = first;
              this.data.autoplay = false;
            }
          }
          this._goto(next);
        },
        tick(t, dt) {
          if (!this.map || !this.data.autoplay || this.data.fps <= 0) return;
          this.timeAcc += dt;
          const frameMs = 1000 / this.data.fps;
          while (this.timeAcc >= frameMs) {
            this.timeAcc -= frameMs;
            this._step();
          }
        },
      });

      // marker-sprite-control: マーカー検出/喪失でスプライト再生を制御
      AFRAME.registerComponent("marker-sprite-control", {
        schema: {
          target: { type: "selector" },
          resetOnFound: { type: "boolean", default: true },
          pauseOnLost: { type: "boolean", default: true },
        },
        init() {
          const marker = this.el;
          const getTarget = () =>
            this.data.target || marker.querySelector("[sprite-sheet]");
          marker.addEventListener("markerFound", () => {
            const t = getTarget();
            if (!t) return;
            const comp = t.components["sprite-sheet"];
            if (comp && this.data.resetOnFound)
              comp._goto(comp.data.startFrame);
            t.setAttribute("sprite-sheet", "autoplay", true);
          });
          marker.addEventListener("markerLost", () => {
            const t = getTarget();
            if (!t) return;
            if (this.data.pauseOnLost)
              t.setAttribute("sprite-sheet", "autoplay", false);
          });
        },
      });
    </script>
  </head>
  <script
    async
    src="https://www.googletagmanager.com/gtag/js?id=G-EZXC8JB271"
  ></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag() {
      dataLayer.push(arguments);
    }
    gtag("js", new Date());
    gtag("config", "G-EZXC8JB271");
  </script>
  <script>
    MicroModal.init();
    function closeModal() {
      const modal = document.getElementById("modal-1");
      modal.classList.remove("is-open");
      modal.setAttribute("aria-hidden", "true");
    }
  </script>
  <body style="margin: 0; overflow: hidden">
    <div id="stamp-get-modal">
      <div class="modal-content">
        <img id="stamp-get-img" src="" alt="スタンプ" />
        <div id="stamp-get-text"></div>
        <button onclick="closeStampGetModal()" ,location>閉じる</button>
      </div>
    </div>
    <div id="swipe-toast" aria-live="polite"></div>
    <div
      class="modal micromodal-slide is-open"
      id="modal-1"
      aria-hidden="false"
    >
      <div class="modal-overlay" tabindex="-1" data-micromodal-close>
        <div
          class="modal-container"
          role="dialog"
          aria-modal="true"
          aria-labelledby="modal-1-title"
        >
          <header class="modal-header">
            <h2 class="modal-title" id="modal-1-title">注意事項</h2>
          </header>
          <div class="modal-content" id="modal-1-content">
            安全のため周囲の物や人から十分な距離を確保して、お楽しみください。<br /><br />もし正常に動作しない際はお近くのスタッフへお問い合わせください。
          </div>
          <button id="closeButton" onclick="closeModal()">閉じる</button>
        </div>
      </div>
    </div>

    <a-scene
      device-orientation-permission-ui="enabled:false"
      vr-mode-ui="enabled: false;"
      loading-screen="enabled: false;"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false; patternRatio: 0.75;"
      id="scene"
      embedded
      global-swipe-handler
    >
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/tets-marker.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/ARイニャー_赤羽台sprite.webp"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="tets-marker.patt"
          sprite-sheet="cols:2; rows:1; fps:8; loop:true; autoplay:true"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/test-2-marker.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content2-AR-Yatai.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="test-2-marker.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker3-AR-Program.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content3-AR-Program.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker3-AR-Program.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker4-AR-Ennichi.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content4-AR-Ennichi.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker4-AR-Ennichi.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker5-AR-Escape.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content5-AR-Escape.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker5-AR-Escape.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker6-AR-Survival.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content6-AR-Survival.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker6-AR-Survival.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker7-AR-Mystery.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content7-AR-Mystery.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker7-AR-Mystery.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker8-AR-Lifegame.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content8-AR-Lifegame.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker8-AR-Lifegame.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker9-AR-Horror.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content9-AR-Horror.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker9-AR-Horror.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker10-AR-Destiny.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content10-AR-Destiny.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker10-AR-Destiny.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker11-AR-Sports.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content11-AR-Sports.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker11-AR-Sports.patt"
        ></a-image>
      </a-marker>
      <a-marker
        type="pattern"
        preset="custom"
        url="assets/marker/pattern-marker12-AR-Stage.patt"
        emitevents="true"
        marker-sprite-control
      >
        <a-image
          src="assets/content/content12-AR-Stage.png"
          scale="3 3 3"
          class="clickable"
          rotation="-90 0 0"
          data-marker-id="pattern-marker12-AR-Stage.patt"
        ></a-image>
      </a-marker>

      <a-entity
        camera
        cursor="rayOrigin: mouse; fuse: false;"
        raycaster="objects: .clickable;"
      ></a-entity>
    </a-scene>
    <script>
      const STAMP_MARKERS = [
        {
          id: "tets-marker.patt",
          name: "Inya",
          img: "assets/content/content1-AR-Inya.png",
          group: 0,
          pt: 1,
        },
        {
          id: "test-2-marker.patt",
          name: "Yatai",
          img: "assets/content/content2-AR-Yatai.png",
          group: 0,
          pt: 2,
        },
        {
          id: "pattern-marker3-AR-Program.patt",
          name: "Program",
          img: "assets/content/content3-AR-Program.png",
          group: 1,
          pt: 1,
        },
        {
          id: "pattern-marker4-AR-Ennichi.patt",
          name: "Ennichi",
          img: "assets/content/content4-AR-Ennichi.png",
          group: 1,
          pt: 2,
        },
        {
          id: "pattern-marker5-AR-Escape.patt",
          name: "Escape",
          img: "assets/content/content5-AR-Escape.png",
          group: 2,
          pt: 1,
        },
        {
          id: "pattern-marker6-AR-Survival.patt",
          name: "Survival",
          img: "assets/content/content6-AR-Survival.png",
          group: 2,
          pt: 2,
        },
        {
          id: "pattern-marker7-AR-Mystery.patt",
          name: "Mystery",
          img: "assets/content/content7-AR-Mystery.png",
          group: 3,
          pt: 1,
        },
        {
          id: "pattern-marker8-AR-Lifegame.patt",
          name: "Lifegame",
          img: "assets/content/content8-AR-Lifegame.png",
          group: 3,
          pt: 2,
        },
        {
          id: "pattern-marker9-AR-Horror.patt",
          name: "Horror",
          img: "assets/content/content9-AR-Horror.png",
          group: 4,
          pt: 1,
        },
        {
          id: "pattern-marker10-AR-Destiny.patt",
          name: "Destiny",
          img: "assets/content/content10-AR-Destiny.png",
          group: 4,
          pt: 2,
        },
      ];
      function getStampStatus() {
        const d = localStorage.getItem("ar_stamps_v2");
        if (!d) return [null, null, null, null, null];
        try {
          const p = JSON.parse(d);
          return Array.isArray(p) ? p : [null, null, null, null, null];
        } catch {
          return [null, null, null, null, null];
        }
      }
      function setStampStatus(a) {
        localStorage.setItem("ar_stamps_v2", JSON.stringify(a));
      }
      function showStampGetModal(s) {
        const m = document.getElementById("stamp-get-modal");
        m.querySelector("#stamp-get-img").src = s.img;
        m.querySelector(
          "#stamp-get-text"
        ).textContent = `${s.name} のスタンプをゲット！ (+${s.pt}pt)`;
        m.style.display = "flex";
      }
      function closeStampGetModal() {
        document.getElementById("stamp-get-modal").style.display = "none";
      }
      let swipeToastTimer = null;
      function showSwipeToast(message = "swiped") {
        const toastEl = document.getElementById("swipe-toast");
        if (!toastEl) return;
        if (swipeToastTimer) {
          clearTimeout(swipeToastTimer);
          swipeToastTimer = null;
        }
        toastEl.textContent = message;
        toastEl.classList.add("show");
        swipeToastTimer = setTimeout(() => {
          toastEl.classList.remove("show");
          swipeToastTimer = null;
        }, 900);
      }

      function markStamp(markerId) {
        console.log("[SwipeDebug] markStamp called", { markerId });
        const newStamp = STAMP_MARKERS.find((s) => s.id === markerId);
        if (!newStamp) return;
        const status = getStampStatus();
        const groupIndex = newStamp.group;
        const existingStamp = status[groupIndex];
        if (!existingStamp || newStamp.pt > existingStamp.pt) {
          status[groupIndex] = {
            name: newStamp.name,
            img: newStamp.img,
            pt: newStamp.pt,
          };
          setStampStatus(status);
          showStampGetModal(newStamp);
        }
      }

      AFRAME.registerComponent("global-swipe-handler", {
        init: function () {
          const component = this;

          component.debugLog = (...args) =>
            console.log("[SwipeDebug]", ...args);

          component.touchStartX = null;
          component.touchStartTime = null;
          component.currentlyHoveredEl = null;
          component.visibleMarkers = new Set();
          component.markerRegistry = {};

          const sceneEl = component.el;

          const registerMarkers = () => {
            component.debugLog("registerMarkers start");
            const allMarkers = sceneEl.querySelectorAll("a-marker");
            allMarkers.forEach((markerEl) => {
              const imageEl = markerEl.querySelector("a-image");
              if (!imageEl) return;
              const markerId = imageEl.getAttribute("data-marker-id");

              if (markerId) {
                component.markerRegistry[markerId] = markerEl;
                component.debugLog("marker registered", { markerId });

                markerEl.addEventListener("markerFound", () => {
                  component.visibleMarkers.add(markerId);
                  component.debugLog("markerFound", {
                    markerId,
                    visibleMarkers: Array.from(component.visibleMarkers),
                  });
                });
                markerEl.addEventListener("markerLost", () => {
                  component.visibleMarkers.delete(markerId);
                  component.debugLog("markerLost", {
                    markerId,
                    visibleMarkers: Array.from(component.visibleMarkers),
                  });
                });
              }
            });
          };

          const trackHoverTargets = () => {
            component.debugLog("trackHoverTargets start");
            const clickableEls = sceneEl.querySelectorAll(".clickable");
            clickableEls.forEach((clickableEl) => {
              clickableEl.addEventListener("mouseenter", () => {
                component.currentlyHoveredEl = clickableEl;
                component.debugLog("mouseenter", {
                  markerId: clickableEl.getAttribute("data-marker-id"),
                });
              });
              clickableEl.addEventListener("mouseleave", () => {
                if (component.currentlyHoveredEl === clickableEl) {
                  component.currentlyHoveredEl = null;
                }
                component.debugLog("mouseleave", {
                  markerId: clickableEl.getAttribute("data-marker-id"),
                });
              });
            });
          };

          component.processSwipe = () => {
            const hoveredId = component.currentlyHoveredEl
              ? component.currentlyHoveredEl.getAttribute("data-marker-id")
              : null;
            component.debugLog("processSwipe", {
              hoveredId,
              visibleMarkers: Array.from(component.visibleMarkers),
            });
            if (component.currentlyHoveredEl) {
              const markerId =
                component.currentlyHoveredEl.getAttribute("data-marker-id");
              if (markerId) {
                const markerEl = component.markerRegistry[markerId];
                if (markerEl && markerEl.object3D.visible) {
                  console.log(
                    "スワイプ成功(直接・検証済)！ 対象マーカー:",
                    markerId
                  );
                  component.debugLog("direct swipe success", { markerId });
                  showSwipeToast();
                  markStamp(markerId);
                  return;
                }
              }
            }

            if (component.visibleMarkers.size === 1) {
              const markerId = component.visibleMarkers.values().next().value;
              if (markerId) {
                const markerEl = component.markerRegistry[markerId];
                if (markerEl && markerEl.object3D.visible) {
                  console.log(
                    "スワイプ成功(間接・検証済)！ 対象マーカー:",
                    markerId
                  );
                  component.debugLog("fallback swipe success", { markerId });
                  showSwipeToast();
                  markStamp(markerId);
                }
              }
            }
          };

          component.resetTouch = () => {
            component.touchStartX = null;
            component.touchStartTime = null;
            component.debugLog("resetTouch");
          };

          component.handleTouchStart = (evt) => {
            if (!evt.touches || evt.touches.length === 0) return;
            component.touchStartX = evt.touches[0].clientX;
            component.touchStartTime = Date.now();
            component.debugLog("touchstart", {
              x: component.touchStartX,
              touches: evt.touches.length,
            });
          };

          component.handleTouchEnd = (evt) => {
            if (component.touchStartX === null) return;
            if (!evt.changedTouches || evt.changedTouches.length === 0) {
              component.resetTouch();
              return;
            }

            const touchEndX = evt.changedTouches[0].clientX;
            const deltaX = touchEndX - component.touchStartX;
            const duration = component.touchStartTime
              ? Date.now() - component.touchStartTime
              : null;
            const dynamicThreshold = (() => {
              if (duration === null) return 40;
              if (duration < 180) return 18;
              if (duration < 300) return 25;
              if (duration < 450) return 32;
              return 40;
            })();
            component.debugLog("touchend", {
              endX: touchEndX,
              deltaX,
              duration,
              threshold: dynamicThreshold,
            });
            component.resetTouch();

            if (Math.abs(deltaX) > dynamicThreshold) {
              component.processSwipe();
            }
          };

          const attachCanvasListeners = (canvasEl) => {
            if (!canvasEl || component.canvasReady) return;
            component.canvasReady = true;
            canvasEl.style.touchAction = "none";
            canvasEl.addEventListener("touchstart", component.handleTouchStart);
            canvasEl.addEventListener("touchend", component.handleTouchEnd);
            canvasEl.addEventListener("touchcancel", component.resetTouch);
            component.debugLog("canvas listeners attached");
          };

          const ensureCanvasReady = () => {
            const canvasEl =
              (sceneEl.renderer && sceneEl.renderer.domElement) ||
              sceneEl.canvas;
            if (canvasEl) {
              attachCanvasListeners(canvasEl);
            } else {
              sceneEl.addEventListener(
                "render-target-loaded",
                () => {
                  const readyCanvas =
                    (sceneEl.renderer && sceneEl.renderer.domElement) ||
                    sceneEl.canvas;
                  attachCanvasListeners(readyCanvas);
                },
                { once: true }
              );
            }
            component.debugLog("ensureCanvasReady invoked", {
              hasRenderer: Boolean(sceneEl.renderer),
            });
          };

          registerMarkers();
          trackHoverTargets();

          if (sceneEl.hasLoaded) {
            ensureCanvasReady();
          } else {
            sceneEl.addEventListener("loaded", ensureCanvasReady, {
              once: true,
            });
          }
        },
      });
    </script>
  </body>
</html>
